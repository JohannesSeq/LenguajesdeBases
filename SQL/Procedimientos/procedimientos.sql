/*
Seccion de pruebas
SELECT * FROM ESTADOS;
SELECT * FROM DISTRITO;
SELECT * FROM CANTON;
SELECT * FROM PROVINCIA;
SELECT * FROM ROL_PERSONA;
SELECT * FROM PERSONAS;
SELECT * FROM DIRECCIONES_PERSONAS;
SELECT * FROM ENCRIPCION_PASSWORDS;
SELECT * FROM CORREOS;
SELECT * FROM PUESTOS;
SELECT * FROM DEPARTAMENTOS;
SELECT * FROM EMPLEADOS;
SELECT * FROM PLATILLOS;
SELECT * FROM MENU;
SELECT * FROM PLATILLOS_MENU;
SELECT * FROM PEDIDOS;
SELECT * FROM METODO_PAGO;
SELECT * FROM LISTA_PLATILLOS;
SELECT * FROM FACTURAS;

SELECT AUTENTICACION('nidiaces@gmail.com','Password1234') AS RESULTADO_AUTH FROM DUAL;
SELECT CALCULAR_TOTAL_PEDIDO(2) FROM DUAL;

--EXEC ACTUALIZAR_TOTAL_PEDIDO(2);
EXEC BORRADO_LOGICO('ST_584551_PERSONAS','Probando_borrado_logico');
*/

---------------------- Correr en session de Playa Cacao---------------------
-- Procedimientos almacenados

------------------- Funcion para crear estados -------------------------------------------------

CREATE OR REPLACE FUNCTION CREAR_ENTRADA_ESTADO(
    P_ID_ENTRADA VARCHAR, P_TABLA VARCHAR, P_COMENTARIO VARCHAR
    ) RETURN VARCHAR
AS

    V_ESTADO_ID VARCHAR(250); --Variable para almacenar el ID Del estado

BEGIN

    --Creacion del valor para el ID de la entrada
    V_ESTADO_ID := 'ST_' || TO_CHAR(P_ID_ENTRADA) || '_' || P_TABLA;
    
    --Creacion del estado que lleva el control de la entrada
    INSERT INTO ESTADOS(ID_ESTADO, TABLA_ENTRADA, COMENTARIO, FECHA_CAMBIO, ESTADO) 
    VALUES (V_ESTADO_ID, P_TABLA, P_COMENTARIO, CURRENT_DATE, 'Activo');
    COMMIT;
    RETURN V_ESTADO_ID;
END;
/

------------------- Funcion para autenticar usuarios -------------------------------------------
CREATE OR REPLACE FUNCTION AUTENTICACION(
    P_EMAIL VARCHAR,
    P_PASSWORD VARCHAR
) RETURN VARCHAR
AS
    --- Variables para la contraseña
    V_LLAVE RAW(32); --Variable para almacenar la llave de encriptacion
    V_PASSWORD_RAW RAW(2000); --Variable para almaacenar la contraseña encriptada
    V_PASSWORD_ID VARCHAR(100); -- Variable para almacenar el ID del password
    V_PASSWORD_DESENCRIPTADO RAW(1000); --Variable para almacenar la contraseña desencriptada
    V_PASSWORD_DESENCRIPTADO_VARCHAR VARCHAR(100);

    V_RESULTADO VARCHAR(100); --Variable para almacenar el valor final de la operacion
    
BEGIN
    V_RESULTADO := 'FALSE'; --Variable para almacenar el valor final de la operacion

    --Obtenemos el valor del id de la contraseña
    SELECT 
        PASSWORD_ID,
        LLAVE_PASSWORD, 
        PASSWORD_VAL
    INTO V_PASSWORD_ID, V_LLAVE, V_PASSWORD_RAW
    FROM VISTA_AUTENTICACION
    WHERE DIRECCION_DE_CORREO = P_EMAIL;

        -- Desencriptar los datos
    V_PASSWORD_DESENCRIPTADO := DBMS_CRYPTO.DECRYPT(
                        src => V_PASSWORD_RAW,
                        typ => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
                        key => V_LLAVE);

    --Convertimos el password de RAW a Varchar
    V_PASSWORD_DESENCRIPTADO_VARCHAR := UTL_RAW.CAST_TO_VARCHAR2(V_PASSWORD_DESENCRIPTADO); 


    IF V_PASSWORD_DESENCRIPTADO_VARCHAR = P_PASSWORD THEN
        V_RESULTADO := 'TRUE';
    END IF;

    RETURN V_RESULTADO;
    
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        V_RESULTADO := 'FALSE';
        RETURN V_RESULTADO;
END;
/

------------ Procedimiento almacenado para enviar la info del usuario autenticado---------------

CREATE OR REPLACE PROCEDURE ENVIO_AUTENTICACION (
    P_CORREO VARCHAR,
    P_PASSWORD VARCHAR,
    P_CURSOR_RESULTADO OUT SYS_REFCURSOR
)
AS
    V_RESULTADO_AUTH VARCHAR(20) := 'False';
BEGIN
    V_RESULTADO_AUTH := AUTENTICACION(P_CORREO,P_PASSWORD);

    IF V_RESULTADO_AUTH = 'TRUE' THEN
        OPEN P_CURSOR_RESULTADO FOR
        SELECT NOMBRE, DIRECCION_DE_CORREO, ROL, NIVEL_PERMISO
        FROM VISTA_AUTENTICACION
        WHERE DIRECCION_DE_CORREO = P_CORREO;

    ELSE

        OPEN P_CURSOR_RESULTADO FOR
        SELECT NOMBRE, DIRECCION_DE_CORREO, ROL
        FROM VISTA_AUTENTICACION
        WHERE DIRECCION_DE_CORREO = 'Invalid';
    END IF;
END;
/

------------------------------ BORRADO LOGICO -----------------------------------------
/*CREATE OR REPLACE PROCEDURE BORRADO_LOGICO(
    P_TABLA VARCHAR,
    P_ID VARCHAR,
    P_COMENTARIO VARCHAR
)
AS
    V_ESTADO_ID VARCHAR(250);
    V_ID_ESTADO VARCHAR(250);
BEGIN

    V_ESTADO_ID := 'ST_' || TO_CHAR(P_ID) || '_' || P_TABLA;

    UPDATE ESTADOS
    SET ESTADO = 'Inactivo', FECHA_CAMBIO = CURRENT_DATE
    WHERE ID_ESTADO = V_ESTADO_ID;

    COMMIT;
END;
/*/

CREATE OR REPLACE PROCEDURE BORRADO_LOGICO(
    P_TABLA IN VARCHAR,
    P_ID IN NUMBER,
    P_COMENTARIO IN VARCHAR
)
AS
    V_ESTADO_ID VARCHAR(250);
BEGIN
    V_ESTADO_ID := 'ST_' || TO_CHAR(P_ID) || '_' || P_TABLA;

    UPDATE ESTADOS
    SET ESTADO = 'Inactivo',
        FECHA_CAMBIO = CURRENT_DATE
    WHERE ID_ESTADO = V_ESTADO_ID;

    COMMIT;
END;
/
EXEC BORRADO_LOGICO('PLATILLOS',45,'Probando Borrado');

------------------------------ CREAR RESERVACION ---------------------------------
CREATE OR REPLACE PROCEDURE CREAR_RESERVACION(
    P_CEDULA_CLIENTE NUMBER,
    P_ID_MESA NUMBER,
    P_ID_HORARIO NUMBER,
    P_CONFIRMACION VARCHAR,
    P_COMENTARIO VARCHAR
)
AS
    V_ID_RESERVA NUMBER;
    V_ESTADO_ID VARCHAR(250);
BEGIN
    INSERT INTO RESERVACIONES(CONFIRMACION, CEDULA_CLIENTE, MESA, ID_HORARIO)
    VALUES (P_CONFIRMACION, P_CEDULA_CLIENTE, P_ID_MESA, P_ID_HORARIO);

    SELECT ID_RESERVA INTO V_ID_RESERVA
    FROM RESERVACIONES
    WHERE CEDULA_CLIENTE = P_CEDULA_CLIENTE
    ORDER BY ID_RESERVA DESC FETCH FIRST 1 ROW ONLY;

    V_ESTADO_ID := CREAR_ENTRADA_ESTADO(TO_CHAR(V_ID_RESERVA), 'RESERVACIONES', P_COMENTARIO);

    UPDATE RESERVACIONES
    SET ID_ESTADO = V_ESTADO_ID
    WHERE ID_RESERVA = V_ID_RESERVA;

    COMMIT;
END;
/

------------------------------ ACTUALIZAR RESERVACION ----------------------------------
CREATE OR REPLACE PROCEDURE ACTUALIZAR_RESERVACION(
    P_ID_RESERVA NUMBER,
    P_NUEVA_CONFIRMACION VARCHAR
)
AS
BEGIN
    UPDATE RESERVACIONES
    SET CONFIRMACION = P_NUEVA_CONFIRMACION
    WHERE ID_RESERVA = P_ID_RESERVA;
    COMMIT;
END;
/






------------------------------ Procedimientos Horarios ----------------------------------

CREATE OR REPLACE PROCEDURE CREAR_HORARIO_MESA (
    P_DISPONIBILIDAD    VARCHAR,
    P_HORA_EXACTA       DATE,
    P_COMENTARIO        VARCHAR
)
AS
    V_ID_HORARIO   NUMBER;
    V_ESTADO_ID    VARCHAR2(250);
BEGIN
    -- Insertar nuevo horario (sin especificar ID_HORARIO)
    INSERT INTO HORARIOS_MESA (DISPONIBILIDAD, HORA_EXACTA, ID_ESTADO)
    VALUES (P_DISPONIBILIDAD, P_HORA_EXACTA, NULL) 
    RETURNING ID_HORARIO INTO V_ID_HORARIO;

    -- Crear entrada en historial de estados
    V_ESTADO_ID := CREAR_ENTRADA_ESTADO(TO_CHAR(V_ID_HORARIO), 'HORARIOS_MESA', P_COMENTARIO);

    -- Actualizar el horario con el ID de estado
    UPDATE HORARIOS_MESA
    SET ID_ESTADO = V_ESTADO_ID
    WHERE ID_HORARIO = V_ID_HORARIO;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Error al crear el horario: ' || SQLERRM);
END CREAR_HORARIO_MESA;
/



----- Probando el Proceso Almacenado -----------


SELECT * FROM HORARIOS_MESA;

SHOW ERRORS PROCEDURE CREAR_HORARIO_MESA;

BEGIN
    CREAR_HORARIO_MESA(
        P_DISPONIBILIDAD => 'DISPONIBLE',
        P_HORA_EXACTA    => TO_DATE('2025-04-17 18:00', 'YYYY-MM-DD HH24:MI'),
        P_COMENTARIO     => 'Horario creado para prueba'
    );
END;
/


/*CREATE TABLE HORARIOS_MESA(
    ID_HORARIO NUMBER PRIMARY KEY,
    DISPONIBILIDAD VARCHAR(10),
    HORA_EXACTA DATE,
    ID_ESTADO VARCHAR(250)
                     CONSTRAINT ESTADO_HORARIOS_FK
                     REFERENCES ESTADOS(ID_ESTADO)
);
*/

---------------------------- Proceso almacenado para actualizar Horario ----------------------------------

CREATE OR REPLACE PROCEDURE ACTUALIZAR_HORARIO_MESA (
    P_ID_HORARIO    NUMBER,
    P_DISPONIBILIDAD VARCHAR,
    P_HORA_EXACTA    DATE
)
AS
BEGIN
    UPDATE HORARIOS_MESA
    SET DISPONIBILIDAD = P_DISPONIBILIDAD,
        HORA_EXACTA = P_HORA_EXACTA
    WHERE ID_HORARIO = P_ID_HORARIO;

    COMMIT;
END;
/

-------------------------------- Para probar la actualizacion -------------------------------

BEGIN
    ACTUALIZAR_HORARIO_MESA(
        P_ID_HORARIO     => 1,  -- Reemplazar por un ID real
        P_DISPONIBILIDAD => 'Ocupado',
        P_HORA_EXACTA    => TO_DATE('2025-04-20 19:00:00', 'YYYY-MM-DD HH24:MI:SS')
    );
END;
/

-- Verificá que se actualizó:
SELECT * FROM VISTA_HORARIOS;



------------------------------ Procedimiento para obtener pedidos cliente ----------------------------

CREATE OR REPLACE PROCEDURE OBTENER_PEDIDOS_CLIENTE (
    P_CEDULA IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
    OPEN P_CURSOR FOR
        SELECT * 
        FROM VISTA_PEDIDOS_CLIENTE
        WHERE CEDULA_CLIENTE = P_CEDULA;
END;
/

------------------------------ Procedimiento para obtener pedidos cliente ----------------------------
/*
CREATE OR REPLACE PROCEDURE CREAR_HORARIO_MESA (
    P_DISPONIBILIDAD    VARCHAR,
    P_HORA_EXACTA       DATE,
    P_COMENTARIO        VARCHAR
)
AS
    V_ID_HORARIO   NUMBER;
    V_ESTADO_ID    VARCHAR2(250);
BEGIN
    -- Insertar nuevo horario (sin especificar ID_HORARIO)
    INSERT INTO HORARIOS_MESA (DISPONIBILIDAD, HORA_EXACTA, ID_ESTADO)
    VALUES (P_DISPONIBILIDAD, P_HORA_EXACTA, NULL) 
    RETURNING ID_HORARIO INTO V_ID_HORARIO;

    -- Crear entrada en historial de estados
    V_ESTADO_ID := CREAR_ENTRADA_ESTADO(TO_CHAR(V_ID_HORARIO), 'HORARIOS_MESA', P_COMENTARIO);

    -- Actualizar el horario con el ID de estado
    UPDATE HORARIOS_MESA
    SET ID_ESTADO = V_ESTADO_ID
    WHERE ID_HORARIO = V_ID_HORARIO;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Error al crear el horario: ' || SQLERRM);
END CREAR_HORARIO_MESA;
/
*/

CREATE OR REPLACE PROCEDURE CREAR_METODO_PAGO (
    P_NOMBRE_METODO    VARCHAR2,
    P_DESCRIPCION      VARCHAR2,
    P_COMENTARIO       VARCHAR2
)
AS
    V_ID_METODO   NUMBER;
    V_ESTADO_ID   VARCHAR2(250);
BEGIN
    -- Validar entrada mínima
    IF P_NOMBRE_METODO IS NULL OR P_DESCRIPCION IS NULL THEN
        RAISE_APPLICATION_ERROR(-20001, 'El nombre y la descripción del método de pago son obligatorios.');
    END IF;

    -- Insertar nuevo método de pago (ID_ESTADO se actualiza después)
    INSERT INTO METODO_PAGO (NOMBRE_METODO, DESCRIPCION, ID_ESTADO)
    VALUES (P_NOMBRE_METODO, P_DESCRIPCION, NULL)
    RETURNING ID_METODO INTO V_ID_METODO;

    -- Crear entrada en historial de estados
    V_ESTADO_ID := CREAR_ENTRADA_ESTADO(TO_CHAR(V_ID_METODO), 'METODO_PAGO', P_COMENTARIO);

    -- Actualizar el método con el ID de estado generado
    UPDATE METODO_PAGO
    SET ID_ESTADO = V_ESTADO_ID
    WHERE ID_METODO = V_ID_METODO;

    -- Confirmar transacción
    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        -- Deshacer cambios y mostrar mensaje personalizado
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Error al crear el método de pago: ' || SQLERRM);
END CREAR_METODO_PAGO;
/


DECLARE
    -- Parámetros de entrada para el procedimiento
    V_NOMBRE_METODO   VARCHAR2(50) := 'Tarjeta de Crédito';
    V_DESCRIPCION     VARCHAR2(250) := 'Pago mediante tarjeta de crédito bancaria.';
    V_COMENTARIO      VARCHAR2(250) := 'Método de pago creado desde script de prueba.';
BEGIN
    -- Llamar al procedimiento
    CREAR_METODO_PAGO(
        P_NOMBRE_METODO => V_NOMBRE_METODO,
        P_DESCRIPCION   => V_DESCRIPCION,
        P_COMENTARIO    => V_COMENTARIO
    );

    DBMS_OUTPUT.PUT_LINE('Método de pago creado correctamente.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

------- Procedimiento eliminar platillo físico ---------------------

CREATE OR REPLACE PROCEDURE ELIMINAR_PLATILLO (
    P_ID_PLATILLO IN NUMBER
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    -- Obtener ID del estado asociado
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM PLATILLOS
    WHERE ID_PLATILLO = P_ID_PLATILLO;

    -- Eliminar platillo
    DELETE FROM PLATILLOS WHERE ID_PLATILLO = P_ID_PLATILLO;

    -- Eliminar estado asociado
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;
END;
/

------------ Eliminar departamento

CREATE OR REPLACE PROCEDURE ELIMINAR_DEPARTAMENTO(
    P_ID_DEPARTAMENTO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM DEPARTAMENTOS
    WHERE ID_DEPARTAMENTO = P_ID_DEPARTAMENTO;

    DELETE FROM DEPARTAMENTOS WHERE ID_DEPARTAMENTO = P_ID_DEPARTAMENTO;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;
    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE_DEPARTAMENTO';
END;
/

------------- Procedimiento para eliminar un empleado

CREATE OR REPLACE PROCEDURE ELIMINAR_EMPLEADO(
    P_ID_EMPLEADO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN

    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM EMPLEADOS
    WHERE ID_EMPLEADO = P_ID_EMPLEADO;

    DELETE FROM EMPLEADOS WHERE ID_EMPLEADO = P_ID_EMPLEADO;

    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;
    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE_EMPLEADO';
END;
/

----------------- Procedimiento para eliminar una persona ---------------------------------------

CREATE OR REPLACE PROCEDURE ELIMINAR_PERSONA(
    P_CEDULA IN VARCHAR,
    P_RESULTADO OUT VARCHAR
)
AS
    
    V_CORREO VARCHAR(100);
    V_ID_DIRECCION_PERSONA VARCHAR(100);
    V_ID_PASSWORD_ID VARCHAR(100);

    V_ID_ESTADO_PERSONA VARCHAR(250);
    V_ESTADO_DIRECCION_PERSONA_ID VARCHAR(250); --Variable para almacenar el estado de la direccion de la persona
    V_ESTADO_CORREOS_ID VARCHAR(250); --Variable para almacenar el estado del correo de la persona
    V_ESTADO_PASSWORD_ENCRIPCION_ID VARCHAR(250); --Variable para almacenar el estado de la contraseña de la persona


BEGIN
    --Obenemos el valor de la cedula
    SELECT ID_ESTADO, DIRECCION_DE_CORREO, ID_DIRECCION, PASSWORD_ID  
    INTO V_ID_ESTADO_PERSONA, V_CORREO, V_ID_DIRECCION_PERSONA, V_ID_PASSWORD_ID
    FROM PERSONAS
    WHERE CEDULA = P_CEDULA;

    --Populamos los id de los estados
    SELECT ID_ESTADO INTO 
    V_ESTADO_CORREOS_ID 
    FROM CORREOS 
    WHERE DIRECCION_DE_CORREO = V_CORREO;

    SELECT ID_ESTADO 
    INTO V_ESTADO_DIRECCION_PERSONA_ID 
    FROM DIRECCIONES_PERSONAS 
    WHERE ID_DIRECCION = V_ID_DIRECCION_PERSONA;

    SELECT ID_ESTADO 
    INTO V_ESTADO_PASSWORD_ENCRIPCION_ID 
    FROM ENCRIPCION_PASSWORDS 
    WHERE PASSWORD_ID = V_ID_PASSWORD_ID;

    --Borrado de la persona y sus dependencias
    DELETE FROM PERSONAS 
    WHERE CEDULA = P_CEDULA;

    DELETE FROM CORREOS 
    WHERE DIRECCION_DE_CORREO = V_CORREO;

    DELETE FROM DIRECCIONES_PERSONAS
    WHERE ID_DIRECCION = V_ID_DIRECCION_PERSONA;

     DELETE FROM ENCRIPCION_PASSWORDS
    WHERE PASSWORD_ID = V_ID_PASSWORD_ID;   

    --Borrado de los estados
    DELETE FROM ESTADOS 
    WHERE ID_ESTADO = V_ID_ESTADO_PERSONA;

    DELETE FROM ESTADOS 
    WHERE ID_ESTADO = V_ESTADO_DIRECCION_PERSONA_ID;

    DELETE FROM ESTADOS 
    WHERE ID_ESTADO = V_ESTADO_CORREOS_ID;

    DELETE FROM ESTADOS 
    WHERE ID_ESTADO = V_ESTADO_PASSWORD_ENCRIPCION_ID;
    
    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE_PERSONA';
END;
/

-------- Eliminar puesto

CREATE OR REPLACE PROCEDURE ELIMINAR_PUESTO(
    P_ID_PUESTO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM PUESTOS
    WHERE ID_PUESTO = P_ID_PUESTO;

    DELETE FROM PUESTOS WHERE ID_PUESTO = P_ID_PUESTO;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;
    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE_PUESTO';
END;
/

---------- Eliminar horario

CREATE OR REPLACE PROCEDURE ELIMINAR_HORARIO (
    P_ID_HORARIO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
    V_EXISTE_REFERENCIA NUMBER := 0;
BEGIN
    -- Verificar si hay mesas que usan este horario
    SELECT COUNT(*) INTO V_EXISTE_REFERENCIA
    FROM MESAS
    WHERE ID_HORARIO = P_ID_HORARIO;

    IF V_EXISTE_REFERENCIA > 0 THEN
        P_RESULTADO := 'REFERENCIAS_ACTIVAS';
        RETURN;
    END IF;

    -- Verificar si hay reservaciones que usan este horario
    SELECT COUNT(*) INTO V_EXISTE_REFERENCIA
    FROM RESERVACIONES
    WHERE ID_HORARIO = P_ID_HORARIO;

    IF V_EXISTE_REFERENCIA > 0 THEN
        P_RESULTADO := 'REFERENCIAS_ACTIVAS';
        RETURN;
    END IF;

    -- Obtener ID_ESTADO del horario
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM HORARIOS_MESA
    WHERE ID_HORARIO = P_ID_HORARIO;

    -- Eliminar el horario y su estado
    DELETE FROM HORARIOS_MESA WHERE ID_HORARIO = P_ID_HORARIO;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
END;
/

---------------------- ELIMINAR MENU ------------------------------

CREATE OR REPLACE PROCEDURE ELIMINAR_MENU (
    P_ID_MENU IN NUMBER
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    -- Obtener el ID del estado asociado al menú
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM MENU
    WHERE ID_MENU = P_ID_MENU;

    -- Eliminar registros relacionados en PLATILLOS_MENU
    DELETE FROM PLATILLOS_MENU WHERE ID_MENU = P_ID_MENU;

    -- Eliminar el menú
    DELETE FROM MENU WHERE ID_MENU = P_ID_MENU;

    -- Eliminar el estado asociado
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;
END;
/

-------- Eliminar mesa
CREATE OR REPLACE PROCEDURE ELIMINAR_MESA (
    P_ID_MESA IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
    V_EXISTE_RESERVA NUMBER := 0;
BEGIN
    -- Verificar si existen reservaciones activas para esta mesa
    SELECT COUNT(*) INTO V_EXISTE_RESERVA
    FROM RESERVACIONES
    WHERE MESA = P_ID_MESA;

    IF V_EXISTE_RESERVA > 0 THEN
        P_RESULTADO := 'REFERENCIAS_ACTIVAS';
        RETURN;
    END IF;

    -- Obtener el ID_ESTADO asociado a la mesa
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM MESAS
    WHERE ID_MESA = P_ID_MESA;

    -- Eliminar la mesa y su estado
    DELETE FROM MESAS WHERE ID_MESA = P_ID_MESA;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
END;
/

----------- Eliminar metodo de pago

CREATE OR REPLACE PROCEDURE ELIMINAR_METODO_PAGO (
    P_ID_METODO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
    V_EXISTE_FACTURA NUMBER := 0;
BEGIN
    -- Verificar si el método de pago está asociado a alguna factura
    SELECT COUNT(*) INTO V_EXISTE_FACTURA
    FROM FACTURAS
    WHERE ID_METODO = P_ID_METODO;

    IF V_EXISTE_FACTURA > 0 THEN
        P_RESULTADO := 'REFERENCIAS_ACTIVAS';
        RETURN;
    END IF;

    -- Obtener el estado asociado al método de pago
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM METODO_PAGO
    WHERE ID_METODO = P_ID_METODO;

    -- Eliminar método de pago y su estado
    DELETE FROM METODO_PAGO WHERE ID_METODO = P_ID_METODO;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
END;
/

------------------ Eliminar pedido

CREATE OR REPLACE PROCEDURE ELIMINAR_PEDIDO (
    P_ID_PEDIDO IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
    V_EXISTE_FACTURA NUMBER := 0;
BEGIN
    -- Verificar si existe alguna factura asociada al pedido
    SELECT COUNT(*) INTO V_EXISTE_FACTURA
    FROM FACTURAS
    WHERE ID_PEDIDO = P_ID_PEDIDO;

    IF V_EXISTE_FACTURA > 0 THEN
        P_RESULTADO := 'REFERENCIAS_ACTIVAS';
        RETURN;
    END IF;

    -- Obtener ID_ESTADO del pedido
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM PEDIDOS
    WHERE ID_PEDIDO = P_ID_PEDIDO;

    -- Eliminar lista de platillos del pedido
    DELETE FROM LISTA_PLATILLOS WHERE ID_PEDIDO = P_ID_PEDIDO;

    -- Eliminar el pedido
    DELETE FROM PEDIDOS WHERE ID_PEDIDO = P_ID_PEDIDO;

    -- Eliminar el estado asociado
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
END;
/

------------- Eliminar Reservaciones

CREATE OR REPLACE PROCEDURE ELIMINAR_RESERVACION (
    P_ID_RESERVA IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    -- Obtener el estado asociado a la reservación
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM RESERVACIONES
    WHERE ID_RESERVA = P_ID_RESERVA;

    -- Eliminar la reservación
    DELETE FROM RESERVACIONES WHERE ID_RESERVA = P_ID_RESERVA;

    -- Eliminar su estado
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE_RESERVA';
END;
/



------------------ Eliminar Platillo menu -------------------

CREATE OR REPLACE PROCEDURE ELIMINAR_PLATILLO_MENU (
    P_ID_PLATILLOS_MENU IN NUMBER,
    P_RESULTADO OUT VARCHAR
)
AS
    V_ID_ESTADO VARCHAR(250);
BEGIN
    SELECT ID_ESTADO INTO V_ID_ESTADO
    FROM PLATILLOS_MENU
    WHERE ID_PLATILLOS_MENU = P_ID_PLATILLOS_MENU;

    DELETE FROM PLATILLOS_MENU WHERE ID_PLATILLOS_MENU = P_ID_PLATILLOS_MENU;
    DELETE FROM ESTADOS WHERE ID_ESTADO = V_ID_ESTADO;

    COMMIT;

    P_RESULTADO := 'BORRADO_FISICO';
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        P_RESULTADO := 'NO_EXISTE';
END;
/
SELECT * FROM ESTADOS;


------------------- Obtener platillos disponibles -------------------

CREATE OR REPLACE PROCEDURE OBTENER_PLATILLOS_DISPONIBLES (
    P_ID_MENU IN NUMBER,
    C_RESULT OUT SYS_REFCURSOR
)
AS
BEGIN
    OPEN C_RESULT FOR
        SELECT P.ID_PLATILLO, P.NOMBRE_PLATILLO
        FROM PLATILLOS P
        JOIN ESTADOS E ON P.ID_ESTADO = E.ID_ESTADO
        WHERE P.ID_PLATILLO NOT IN (
            SELECT PM.ID_PLATILLO
            FROM PLATILLOS_MENU PM
            WHERE PM.ID_MENU = P_ID_MENU
        )
        AND E.ESTADO = 'Activo';
END;
/

----------------------- Obtener los platillos del pedido --------------------
CREATE OR REPLACE PROCEDURE OBTENER_PLATILLOS_PEDIDO(
    P_ID_PEDIDO IN NUMBER,
    C_RESULT OUT SYS_REFCURSOR
)
AS
BEGIN
    OPEN C_RESULT FOR
    SELECT NOMBRE_PLATILLO, PRECIO_DEL_PLATILLO
    FROM VISTA_PEDIDOS_PLATILLOS
    WHERE LISTA_ID_PEDIDO = P_ID_PEDIDO;
END;